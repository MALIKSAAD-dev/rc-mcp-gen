#!/usr/bin/env node
// ============================================================
// rocketchat-mcp-server
// Auto-generated by rc-mcp-generator
// Tools: 8 | Categories: auth, channels, messaging
// ============================================================

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RC_URL = process.env.ROCKETCHAT_URL || "http://localhost:3000";
let authToken = "";
let userId = "";

// â”€â”€ HTTP Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function rcApi(method: string, path: string, body?: any, query?: Record<string, string>): Promise<any> {
  const url = new URL(path, RC_URL);
  if (query) {
    Object.entries(query).forEach(([k, v]) => {
      if (v !== undefined && v !== null && v !== "") url.searchParams.set(k, String(v));
    });
  }

  const headers: Record<string, string> = { "Content-Type": "application/json" };
  if (authToken && userId) {
    headers["X-Auth-Token"] = authToken;
    headers["X-User-Id"] = userId;
  }

  const res = await fetch(url.toString(), {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });

  const data = await res.json();
  if (!res.ok) throw new Error(`RC API error ${res.status}: ${JSON.stringify(data)}`);
  return data;
}

// â”€â”€ MCP Server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const server = new McpServer({
  name: "rocketchat-mcp-server",
  version: "1.0.0",
});

// â”€â”€ Tool Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tool: login â€” Authenticate a user with username/email and password. Returns authToken and userId.
server.tool(
  "login",
  "Authenticate a user with username/email and password. Returns authToken and userId.",
  {
    user: z.string().describe("Username or email"),
    password: z.string().describe("User password")
  },
  async (args) => {
      const result = await rcApi("POST", "/api/v1/login", { user: args.user, password: args.password });
      authToken = result.data?.authToken || "";
      userId = result.data?.userId || "";
      return { content: [{ type: "text" as const, text: JSON.stringify({ success: true, userId, message: "Logged in successfully" }, null, 2) }] };
  }
);

// Tool: me â€” Get the authenticated user's profile information including username, email, and roles.
server.tool(
  "me",
  "Get the authenticated user's profile information including username, email, and roles.",
  {},
  async (args) => {
      const result = await rcApi("GET", "/api/v1/me", undefined, {  });
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// Tool: channels.list â€” List all public channels on the server. Supports pagination with offset and count.
server.tool(
  "channels.list",
  "List all public channels on the server. Supports pagination with offset and count.",
  {
    offset: z.number().optional().describe("Number of items to skip"),
    count: z.number().optional().describe("Number of items to return")
  },
  async (args) => {
      const result = await rcApi("GET", "/api/v1/channels.list", undefined, { offset: args.offset as any, count: args.count as any });
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// Tool: channels.history â€” Retrieve message history for a specific channel. Supports pagination and date filtering.
server.tool(
  "channels.history",
  "Retrieve message history for a specific channel. Supports pagination and date filtering.",
  {
    roomId: z.string().describe("The channel ID"),
    count: z.number().optional().describe("Number of messages to return"),
    offset: z.number().optional().describe("Number of messages to skip"),
    latest: z.string().optional().describe("ISO timestamp â€” newest message date"),
    oldest: z.string().optional().describe("ISO timestamp â€” oldest message date")
  },
  async (args) => {
      const result = await rcApi("GET", "/api/v1/channels.history", undefined, { roomId: args.roomId as any, count: args.count as any, offset: args.offset as any, latest: args.latest as any, oldest: args.oldest as any });
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// Tool: chat.sendMessage â€” Send a new message to a channel or direct message. Supports attachments and formatting.
server.tool(
  "chat.sendMessage",
  "Send a new message to a channel or direct message. Supports attachments and formatting.",
  {
    message: z.record(z.any()).describe("Message object with rid (room ID) and msg (text)")
  },
  async (args) => {
      const result = await rcApi("POST", "/api/v1/chat.sendMessage", args);
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// Tool: chat.postMessage â€” Post a message to a channel using channel name or ID. Simpler alternative to sendMessage.
server.tool(
  "chat.postMessage",
  "Post a message to a channel using channel name or ID. Simpler alternative to sendMessage.",
  {
    channel: z.string().optional().describe("Channel name (e.g., #general)"),
    roomId: z.string().optional().describe("Room ID"),
    text: z.string().describe("Message text"),
    alias: z.string().optional().describe("Display name alias"),
    emoji: z.string().optional().describe("Emoji avatar (e.g., :smirk:)"),
    avatar: z.string().optional().describe("Avatar URL")
  },
  async (args) => {
      const result = await rcApi("POST", "/api/v1/chat.postMessage", args);
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// Tool: chat.getMessage â€” Retrieve a single message by its ID.
server.tool(
  "chat.getMessage",
  "Retrieve a single message by its ID.",
  {
    msgId: z.string().describe("The message ID")
  },
  async (args) => {
      const result = await rcApi("GET", "/api/v1/chat.getMessage", undefined, { msgId: args.msgId as any });
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// Tool: chat.search â€” Search for messages in a specific room matching a search term.
server.tool(
  "chat.search",
  "Search for messages in a specific room matching a search term.",
  {
    roomId: z.string().describe("The room ID"),
    searchText: z.string().describe("Text to search for"),
    count: z.number().optional().describe("Number of results to return")
  },
  async (args) => {
      const result = await rcApi("GET", "/api/v1/chat.search", undefined, { roomId: args.roomId as any, searchText: args.searchText as any, count: args.count as any });
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };
  }
);

// â”€â”€ Start Server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(`ðŸš€ ${server.server.name} running on stdio â€” 8 tools loaded`);
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(1);
});
