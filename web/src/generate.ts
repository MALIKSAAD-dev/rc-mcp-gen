import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import type { ApiEndpoint } from './data';

function zodType(type: string): string {
    switch (type) {
        case 'string': return 'z.string()';
        case 'number': return 'z.number()';
        case 'boolean': return 'z.boolean()';
        case 'object': return 'z.record(z.any())';
        case 'array': return 'z.array(z.any())';
        default: return 'z.string()';
    }
}

function generateToolBlock(ep: ApiEndpoint): string {
    const schemaEntries = ep.parameters.map(p => {
        const z = p.required ? zodType(p.type) : `${zodType(p.type)}.optional()`;
        return `    ${p.name}: ${z}.describe("${p.description}")`;
    });
    const schema = schemaEntries.length > 0 ? `{\n${schemaEntries.join(',\n')}\n  }` : '{}';

    let handler: string;
    if (ep.id === 'login') {
        handler = `
      const result = await rcApi("POST", "${ep.path}", { user: args.user, password: args.password });
      authToken = result.data?.authToken || "";
      userId = result.data?.userId || "";
      return { content: [{ type: "text" as const, text: JSON.stringify({ success: true, userId, message: "Logged in" }, null, 2) }] };`;
    } else if (ep.id === 'logout') {
        handler = `
      const result = await rcApi("POST", "${ep.path}");
      authToken = ""; userId = "";
      return { content: [{ type: "text" as const, text: JSON.stringify({ success: true, message: "Logged out" }, null, 2) }] };`;
    } else if (ep.method === 'GET') {
        const q = ep.parameters.map(p => `${p.name}: args.${p.name} as any`).join(', ');
        handler = `
      const result = await rcApi("GET", "${ep.path}", undefined, { ${q} });
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };`;
    } else {
        handler = `
      const result = await rcApi("POST", "${ep.path}", args);
      return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }] };`;
    }

    return `// ${ep.id} â€” ${ep.description}
server.tool("${ep.id}", "${ep.description}", ${schema}, async (args) => {${handler}\n});`;
}

function generateServerTs(endpoints: ApiEndpoint[]): string {
    const cats = [...new Set(endpoints.map(e => e.category))].join(', ');
    return `#!/usr/bin/env node
// Auto-generated by rc-mcp-gen | Tools: ${endpoints.length} | Categories: ${cats}

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const RC_URL = process.env.ROCKETCHAT_URL || "http://localhost:3000";
let authToken = "";
let userId = "";

async function rcApi(method: string, path: string, body?: any, query?: Record<string, string>): Promise<any> {
  const url = new URL(path, RC_URL);
  if (query) Object.entries(query).forEach(([k, v]) => { if (v != null && v !== "") url.searchParams.set(k, String(v)); });
  const headers: Record<string, string> = { "Content-Type": "application/json" };
  if (authToken && userId) { headers["X-Auth-Token"] = authToken; headers["X-User-Id"] = userId; }
  const res = await fetch(url.toString(), { method, headers, body: body ? JSON.stringify(body) : undefined });
  const data = await res.json();
  if (!res.ok) throw new Error(\`RC API error \${res.status}: \${JSON.stringify(data)}\`);
  return data;
}

const server = new McpServer({ name: "rocketchat-mcp-server", version: "1.0.0" });

${endpoints.map(ep => generateToolBlock(ep)).join('\n\n')}

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(\`ðŸš€ MCP server running â€” ${endpoints.length} tools loaded\`);
}
main().catch(err => { console.error("Fatal:", err); process.exit(1); });
`;
}

export async function downloadServer(endpoints: ApiEndpoint[]) {
    const zip = new JSZip();

    const pkg = {
        name: 'rocketchat-mcp-server',
        version: '1.0.0',
        description: `Minimal MCP server â€” ${endpoints.length} tools`,
        scripts: { build: 'tsc', start: 'ts-node src/server.ts' },
        dependencies: { '@modelcontextprotocol/sdk': '^1.12.1', zod: '^3.23.0' },
        devDependencies: { typescript: '^5.4.0', 'ts-node': '^10.9.2', '@types/node': '^20.11.0' },
    };

    const tsconfig = {
        compilerOptions: { target: 'ES2020', module: 'commonjs', lib: ['ES2020'], outDir: './dist', rootDir: './src', strict: true, esModuleInterop: true, skipLibCheck: true, sourceMap: true },
        include: ['src/**/*'],
    };

    zip.file('package.json', JSON.stringify(pkg, null, 2));
    zip.file('tsconfig.json', JSON.stringify(tsconfig, null, 2));
    zip.file('src/server.ts', generateServerTs(endpoints));
    zip.file('README.md', `# Minimal MCP Server\n\n${endpoints.length} tools. Install: \`npm install\`. Run: \`npx ts-node src/server.ts\`.`);

    const blob = await zip.generateAsync({ type: 'blob' });
    saveAs(blob, 'rocketchat-mcp-server.zip');
}
